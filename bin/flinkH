#!/usr/bin/python3
# Debian User Recipe Toolkit Helper
# Copyright (C) 2019 M. Zhou <lumin@debian.org>
import argparse, re, sys, os, json, time, getpass, socket
import yaml


def main_dumpyaml(argv):
    ag = argparse.ArgumentParser()
    ag.add_argument('yaml', type=str, help='yaml file')
    ag.add_argument('--output', type=str, default='',
            help='redirect json dump to specifid file')
    ag = ag.parse_args(argv)
    if not ag.output:
        print(json.dumps(yaml.load(open(ag.yaml).read()), indent=2))
    else:
        with open(ag.output, 'w') as f:
            f.write(json.dumps(yaml.load(open(ag.yaml).read()), indent=2))


def main_subst(argv):
    ag = argparse.ArgumentParser()
    ag.add_argument('--yaml', type=str, help='source yaml file')
    ag.add_argument('target', type=str, help='target file')
    ag = ag.parse_args(argv)
    yml = yaml.load(open(ag.yaml, 'r').read())
    lines = open(ag.target, 'r').readlines()
    r_stub = re.compile('@[-\w\_]*?@')
    updated_lines = []
    for (i, line) in enumerate(lines):
        stubs = r_stub.findall(line)
        if stubs:
            #print(i, line.strip())
            for stub in stubs:
                stub = stub.replace('@', '')
                if stub not in yml.keys():
                    print(f"flinkH-warn: Ignoring invalid key '@{stub}@'")
                    continue
                value = yml[stub]
                line = line.replace(f'@{stub}@',
                        str(value) if (value is not None) else ' ')
                sys.stderr.write(f'line[{i}]: @{stub}@ -> {value}\n')
        updated_lines.append(line)
    with open(ag.target, 'w') as f:
        f.writelines(updated_lines)


def main_gen_debian_source_format(argv):
    '''
    Generate debian/source/format. When key 'Revision' exists in the YAML
    file, we use quilt format instead of native format.
    '''
    ag = argparse.ArgumentParser()
    ag.add_argument('-y', '--yaml', type=str, required=True)
    ag.add_argument('-d', '--dest', type=str, default=None)
    ag = ag.parse_args(argv)
    # generate
    path = './debian/source/format' if (ag.dest is None) else os.path.join(
            ag.dest, 'debian/source/format')
    if not os.path.exists(os.path.dirname(path)):
        os.makedirs(os.path.dirname(path))
    meta = yaml.load(open(ag.yaml).read())
    f = open(path, 'w')
    if 'Revision' in meta.keys():
        f.write('3.0 (quilt)\n')
        print(f'flinkH: {path} | 3.0 (quilt)')
    else:
        f.write('3.0 (native)\n')
        print(f'flinkH: {path} | 3.0 (native)')
    f.close()


def main_gen_debian_changelog(argv):
    '''
    Generate debian/changelog. When 'Maintainer' is not defined, we read
    environment variables 'DEBFULLNAME' and 'DEBEMAIL'. If they don't exist
    as well, we use "USER <USER@HOSTNAME>" as the maintainer.
    '''
    ag = argparse.ArgumentParser()
    ag.add_argument('-y', '--yaml', type=str, required=True)
    ag.add_argument('-d', '--dest', type=str, default=None)
    ag = ag.parse_args(argv)
    # generate
    path = './debian/changelog' if (ag.dest is None) else os.path.join(
            ag.dest, 'debian/changelog')
    if not os.path.exists(os.path.dirname(path)):
        os.makedirs(os.path.dirname(path))
    meta = yaml.load(open(ag.yaml).read())
    if not all(x in meta.keys() for x in ['Source', 'Version']):
        raise Exception("'Source' and 'Version' are required.")
    f = open(path, 'w')
    v = str(meta['Version']) + (f'-{meta["Revision"]}' if 'Revision' in meta else '')
    f.write(f'{meta["Source"]} ({v}) Custom; urgency=low\n')
    f.write('\n')
    f.write('  * Built From Debian User Recipe.\n')
    f.write('\n')
    maintainer = meta.get('Maintainer', None)
    stamp = time.strftime('%a, %d %b %Y %H:%M:%S %z')
    if maintainer is None:
        fullname, email = os.getenv('DEBFULLNAME'), os.getenv('DEBEMAIL')
        if fullname is None or email is None:
            fullname = getpass.getuser()
            email = socket.gethostname()
        maintainer = f'{fullname} <{email}>'
    f.write(f' - {maintainer}  {stamp}')
    f.close()
    print(f'flinkH: {path} | {maintainer} @ {stamp}')


def main_gen_debian_rules(argv):
    '''
    Generate debian/rules. Debhelper-Buildsystem, Debhelper-Plugins will
    be used to tweak the rules content. The content of override_* keys
    in YAML will be copied to rules literally.
    '''
    ag = argparse.ArgumentParser()
    ag.add_argument('-y', '--yaml', type=str, required=True)
    ag.add_argument('-d', '--dest', type=str, default=None)
    ag = ag.parse_args(argv)
    # generate
    path = './debian/rules' if (ag.dest is None) else os.path.join(
            ag.dest, 'debian/rules')
    if not os.path.exists(os.path.dirname(path)):
        os.makedirs(os.path.dirname(path))
    meta = yaml.load(open(ag.yaml).read())
    f = open(path, 'w')
    f.write('#!/usr/bin/make -f\n')
    f.write('export DEB_BUILD_MAINT_OPTIONS = hardening=+all\n')
    f.write('\n')
    f.write('%:\n')
    f.write('\tdh $@')
    buildsystem = meta.get('Debhelper-Buildsystem', None)
    if buildsystem is not None:
        f.write(' -S' + meta['Debhelper-Buildsystem'])
    plugins = meta.get('Debhelper-Plugins', None)
    if plugins is not None:
        plugins = ','.join(plugins.replace(',',' ').split())
        f.write(' --with ' + plugins)
    f.write('\n')
    print(f'flinkH: {path} | -S{buildsystem} --with {plugins}')
    for override in (x for x in meta.keys() if x.startswith('override_')):
        f.write('\n')
        f.write(f'{override}:\n')
        for line in meta[override].strip().split('\n'):
            f.write(f'\t{line}\n')
        print(f'flinkH: {path} | wrote {override}')
    f.close()
    os.chmod(path, 0o755)


def main_gen_debian_copyright(argv):
    '''
    Generate debian/copyright. Will copy the 'License' field from YAML.
    If that field doesn't exist, we call external copyright scanners
    such as debmake or licensecheck, etc.
    '''
    ag = argparse.ArgumentParser()
    ag.add_argument('-y', '--yaml', type=str, required=True)
    ag.add_argument('-d', '--dest', type=str, default=None)
    ag = ag.parse_args(argv)
    # generate
    path = './debian/copyright' if (ag.dest is None) else os.path.join(
            ag.dest, 'debian/copyright')
    if not os.path.exists(os.path.dirname(path)):
        os.makedirs(os.path.dirname(path))
    meta = yaml.load(open(ag.yaml).read())
    if 'License' not in meta.keys():
        raise NotImplementedError("calling external license scanner has not been implemented yet.")
    f = open(path, 'w')
    f.write(meta['License'] + '\n')
    f.close()
    print(f'flinkH: {path} | {meta["License"]}')


def main_gen_debian(argv):
    '''
    Generate the debian/ directory.
    '''
    ag = argparse.ArgumentParser()
    ag.add_argument('-y', '--yaml', type=str, required=True)
    ag.add_argument('-d', '--dest', type=str, default=None)
    ag = ag.parse_args(argv)
    # call the other helpers
    main_gen_debian_source_format(argv)
    main_gen_debian_changelog(argv)
    main_gen_debian_rules(argv)
    main_gen_debian_copyright(argv)


def _gen_debian_control(dst, meta):
    '''
    	if ! test -r $1/debian/control; then
		if test -z "$src"; then echo "DK: Please define 'src'"; false; fi
		if test -z "$section"; then echo "DK: Please define 'section'"; false; fi
		if test -z "$stdver"; then stdver="4.3.0"; fi
		if test -z "$compat"; then compat="11"; fi
		if test -z "$maintainer"; then echo "DK: Please define 'maintainer'"; false; fi
		if test -z "$description"; then echo "DK: Please define 'description'"; false; fi
		if test -n "$DK_VERBOSE"; then echo "DK: Generating $1/debian/control"; fi
		build_depends_="$build_depends"
		if test -n "$(echo $dh_with | grep -o python)"; then
			build_depends_="$build_depends_,dh-python";
	   	fi
		if test -n "$(echo $dh_with | grep -o python3)"; then
			build_depends_="$build_depends_,python3-all,python3-all-dev";
		fi
		if test -n "$(echo $dh_with | grep -oP 'python[^3$]')"; then
			build_depends_="$build_depends_,python-all,python-all-dev":
	   	fi
		mkdir -p $1/debian
		cat > $1/debian/control <<EOF
Source: $src
Section: $section
Homepage: $homepage
Priority: optional
Standards-Version: $stdver
Maintainer: D**ian User Repo Contributors
Uploaders: $maintainer
Build-Depends: debhelper-compat (= $compat), $build_depends_

Package: $src
Architecture: any
Multi-Arch: no
Depends: \${shlibs:Depends}, \${python:Depends}, \${python3:Depends},
  \${misc:Depends}, \${misc:Pre-Depends}, $depends
Description: $description
 $description
EOF
	fi
    '''
    pass


def main_prep_source(argv):
    '''
    	if test -d $src; then
		echo "DK: Could you please remove $src/ directory first?"
		exit 1
	fi
	mkdir $src;
	if test $(tar tf ${src}_${version}.tar.* | awk -F/ '{m=9} NF<m{m=NF} END{print m}') = 1; then
		tar xf ${src}_${version}.tar.* -C $src/
	else
		tar xf ${src}_${version}.tar.* --strip-components=1 -C $src/
	fi
    '''
    pass

def main_debianize(argv):
    '''
    	dkGenerate $src
	dkSubst_ ${0%.sh}.hft
	hft -v -u ${0%.sh}.hft -d $src/ -F
    '''
    pass


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f'Usage: {__file__} <ACTION> [<ARGUMENTS>]')
        print('Actions:')
        print('  ', [k.replace('main_', '')
            for (k, v) in locals().items() if k.startswith('main')])
        exit(0)
    # NOTE: I don't like the subparsers (argparse).
    eval(f'main_{sys.argv[1]}')(sys.argv[2:])

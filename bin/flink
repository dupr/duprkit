#!/usr/bin/perl6
=begin DESCRIPTION
FLINK: Debian User Recipes
Copyright (C) 2019 M. Zhou <lumin@debian.org>

Recipe-Specification
--------------------
A .rcp file is a concatenation of a shell script and an HFT file.
It defines how to get and prepare the source tree, as well as how to
debianize the source tree.

Recipe Example
--------------

::
    src="foobar"
    ^ debian/compat
    11
    ^ debian/source/format
    3.0 (native)
=end DESCRIPTION

constant $__version__ = '0.1a';
constant $SH = '/bin/sh';
constant $DUPR_DEFCOLL = "$*HOME/.defcoll";
constant $COLLECTOR = '/usr/bin/duprCollector';
constant $GIT = '/usr/bin/git';
constant $TEMPLATE = '/usr/share/doc/duprkit/examples/template.rcp';
constant $PYTHON3 = '/usr/bin/python3';
constant $FLINKH = '/usr/bin/flinkH';
constant $FLINK = '/usr/bin/flink';
constant $CACHEDIR = "$*HOME/.cache/duprkit/distfiles/";
constant $_C162 = "\x1b[1;38;5;162m";
constant $_C36  = "\x1b[1;36m";
constant $_c    = "\x1b[0m";

sub flink_fetch () {
	if $DUPR_DEFCOLL.IO.d {
		say "{$_C162}→ Cloning {$_C36}DefaultCollection{$_C162} ...{$_c}";
		chdir $DUPR_DEFCOLL;
		run $GIT, 'pull';
	} else {
		say "{$_C162}→ Pulling {$_C36}DefaultCollection{$_C162} ...{$_c}";
		run $GIT, 'clone', 'https://github.com/dupr/DefaultCollection',  $DUPR_DEFCOLL;
	}
}

sub flink_split (Str $PATH)
{
	$PATH.IO.f || die "Non-existent file [$PATH]!" ;
	$PATH ~~ /.*.rcp$/ || die "Unsupported file $PATH !";
	print "{$_C162}→ Splitting {$_C36} $PATH {$_C162}into";
    say " {$_C36}.yaml {$_C162}and {$_C36}.hft {$_C162}...{$_c}";

	my $path_yml = $PATH.IO.basename.subst(/\.rcp$/, '.yaml');
	my $path_hft = $PATH.IO.basename.subst(/\.rcp$/, '.hft');
	my $path_json = $PATH.IO.basename.subst(/\.rcp$/, '.json');
	my $fp_yml := open :w, $path_yml;
	my $fp_hft := open :w, $path_hft;
	my $fp = $fp_yml;
	for $PATH.IO.lines {
		if m/^\^/ { $fp = $fp_hft; }
		$fp.say: $_;
	}
	close $fp_yml; close $fp_hft;
	say "{$_C162}Replacing placeholders in YAML file...{$_c}";
	run $FLINKH, 'subst', '--yaml', $path_yml, $path_yml;
	say "{$_C162}Replacing placeholders in HFT file...{$_c}";
	run $FLINKH, 'subst', '--yaml', $path_yml, $path_hft;
	say "{$_C162}Dumping YAML content into JSON file...{$_c}";
	run $FLINKH, 'dumpyaml', $path_yml, '--output', $path_json;
	say "{$_C162}Creating pipeline shell script...{$_c}";
	run $FLINKH, 'pipeline_sh', '--yaml', $path_yml;
	say 'Dumping YAML content:';
	run $FLINKH, 'dumpyaml', $path_yml;
}

sub flink_cache (Str $PKG, Str $URL)
{
	my $cache = $CACHEDIR ~ '/' ~ $PKG;
	$CACHEDIR.IO.mkdir if not $CACHEDIR.IO.d;
	if not $cache.IO.r {
		run 'wget', $URL, '-O', $cache;
	}
	run 'cp', '-v', $cache, $PKG;
}

sub flink_checksum (Str $FILE, Str $TYPE, Str $HASH)
{
	#FIXME
	say "NotImplemented";
}

sub flink_unfold (Str $PATH)
{
	flink_split $PATH;
	my $shell_file = $PATH.IO.basename.subst(/\.rcp$/, '.sh');
	say "{$_C162}→ Executing {$_C36}{$shell_file} {$_C162}...{$_c}";
	run $SH, $shell_file;
}

sub flink_create (Str $NAME)
{
	run 'cp','-v', $TEMPLATE, $NAME ~ '.rcp';
}

sub flink_minimal (Str $NAME)
{
	my $fp = open :w, $NAME ~ '.rcp';
	for $TEMPLATE.IO.lines {
		if !m/^\^\#/ && !m/^\s*\#/ || m/^\#\!/ {
			$fp.say: $_;
		} #else { .say }
	}
}

sub flink_buildpackage (Str $PATH, Str $OPTS)
{
	flink_split $PATH;
	my $shell_file = $PATH.IO.basename.subst(/\.rcp$/, '.sh');
	my $hft_file = $PATH.IO.basename.subst(/\.rcp$/, '.hft');
	my $yaml_file = $PATH.IO.basename.subst(/\.rcp$/, '.yaml');
	my $json_file = $PATH.IO.basename.subst(/\.rcp$/, '.json');
	# add something to the pipeline before execution
	my $fp_shell = open :a, $shell_file;
	$fp_shell.say: '# Automatically appended by FLINK';
	$fp_shell.say: 'export PATH=/usr/lib/ccache:$PATH';
	$fp_shell.say: 'cd $Source';
	$fp_shell.say: "dpkg-buildpackage $OPTS";
	$fp_shell.close;
	# execute shell script now
	say "{$_C162}→ Executing {$_C36}{$shell_file} {$_C162}...{$_c}";
	run $SH, $shell_file;
	# cleanup files
	$shell_file.IO.unlink;
	$hft_file.IO.unlink;
	$yaml_file.IO.unlink;
	$json_file.IO.unlink;
}

sub flink_guess () {
	say "Source: ", '.'.IO.absolute.IO.basename;
	say "Section: ", 'utils';
	say "Version: ", '.git/config'.IO.f ?? qx!git describe --tags 2>/dev/null!.chomp !! '0';
	say "Description: ", '.'.IO.absolute.IO.basename;
	if '.git/config'.IO.f {
		my $homepage = qx/git remote get-url origin/.chomp
			.subst(':', '/').subst('git@', 'https://');
		say 'Homepage: ', $homepage;
	}
	if 'LICENSE'.IO.f || 'COPYING'.IO.f {
		# FIXME use flinkV
		if 'LICENSE'.IO.f {
			my $tmp = 'LICENSE'.IO.slurp;
			if $tmp ~~ /MIT/ {
				say 'License: ', 'MIT';
			}
		} elsif 'COPYING'.IO.f {
			my $tmp = 'LICENSE'.IO.slurp;
			if $tmp ~~ /MIT/ {
				say 'License: ', 'MIT';
			}
		}
	} else {
		# FIXME call autoscanner
	}
	# /usr/share/perl5/Debian/Debhelper/Buildsystem/
	if "CMakeLists.txt".IO.f {
		say "Debhelper-Buildsystem: ", "cmake";
	} elsif "setup.py".IO.f {
		# NOTE Don't ever use the deprecated python_distutils build system
		say "Debhelper-Buildsystem: ", "pybuild";
	} elsif "build.rs".IO.f || "Cargo.toml".IO.f {
		say "Debhelper-Buildsystem: ", "cargo";
	} elsif "go.mod".IO.f || "main.go".IO.f {
		say "Debhelper-Buildsystem: ", "golang";
	} elsif "build.xml".IO.f {
		say "Debhelper-Buildsystem: ", "ant";
	} elsif "meson.build".IO.f {
		say "Debhelper-Buildsystem: ", "meson";
	} elsif "build.ninja".IO.f {
		say "Debhelper-Buildsystem: ", "ninja";
	} elsif "Build.PL".IO.f {
		say "Debhelper-Buildsystem: ", "perl_build";
	} elsif "Makefile.PL".IO.f {
		say "Debhelper-Buildsystem: ", "perl_makemaker";
	} elsif "BUILD".IO.f || "WORKSPACE".IO.f {
		say "Debhelper-Buildsystem: ", "bazel (Not Yet Supported)";
	} elsif "configure".IO.f {
		say "Debhelper-Buildsystem: ", "autoconf";
	} elsif "Makefile".IO.f {
		# XXX The most common one is last checked
		say "Debhelper-Buildsystem: ", "makefile";
	} else {
		# Well, I don't know.
	}
	if '.git/config'.IO.f {
		say 'Uscan: ', qx/git remote get-url origin/.chomp;
	}
	say '';
	say 'Recipe-Binaries:';
    say ' ' x 4, '.'.IO.absolute.IO.basename, ':';
	if 'doc'.IO.d || 'docs'.IO.d || 'README.md'.IO.f {
		say ' ' x 8, 'docs: |';
		say(' ' x 12, 'README.md') if 'README.md'.IO.f;
		say(' ' x 12, 'doc/*') if 'doc'.IO.d;
		say(' ' x 12, 'docs/*') if 'docs'.IO.d;
	}
	if 'example'.IO.d || 'examples'.IO.d {
		say ' ' x 8, 'examples: |';
		say(' ' x 12, 'example/*') if 'example'.IO.d;
		say(' ' x 12, 'examples/*') if 'examples'.IO.d;
	}
	if 'bin'.IO.d {
		say ' ' x 8, 'install: |';
		say(' ' x 12, 'bin/* usr/bin/') if 'bin'.IO.d;
	}
	say '';
	if 'CMakeLists.txt'.IO.f {
		say 'override_dh_auto_configure: |';
		say ' ' x 4, 'dh_auto_configure -- \\';
		say ' ' x 8, '-DCMAKE_BUILD_TYPE=Release';
	}
}

sub flink_boldguess () {
	shell 'flink guess > flinkBoldGuess.rcp';
	shell 'flinkH gen_debian -y flinkBoldGuess.rcp -d .';
	'flinkBoldGuess.rcp'.IO.unlink;
}

sub MAIN (Str $ACTION, Str $TARGET = "", Str $ARGV3 = "", Str $ARGV4 = "")
{
	given $ACTION {
		when 'f' | 'fetch' {
			flink_fetch;
		}
		when 'l' | 'ls' | 'list' {
			if $TARGET.chars {
				run $COLLECTOR, '-s', $TARGET, $DUPR_DEFCOLL;
			} else {
				run $COLLECTOR, $DUPR_DEFCOLL;
			}
		}
		when 's' | 'split' {
			flink_split $TARGET;
		}
		when 'cache' {
			flink_cache $TARGET, $ARGV3;
		}
		when 'checksum' {
			flink_checksum $TARGET, $ARGV3, $ARGV4;
		}
		when 'u' | 'unfold' {
			flink_unfold $TARGET;
		}
		when 'c' | 'create' {
			flink_create $TARGET;
		}
		when 'm' | 'minimal' {
			flink_minimal $TARGET;
		}
		when 'dsc' {
			flink_buildpackage $TARGET, '-nc -us -uc -S';
		}
		when 'deb' {
			flink_buildpackage $TARGET, '-nc -us -uc';
		}
		when 'g' | 'guess' {
			flink_guess;
		}
		when 'bg' | 'boldguess' {
			flink_boldguess;
		}
		default {
			die "Unknown action???"
		}
	}
}

sub USAGE() {
    print qq :to/EOH/;
{$_C162}-- Debian User Recipe ToolKit $__version__ --{$_c}
Usage: {$*PROGRAM-NAME} action [args]

Actions
   f|fetch                  Fetch the recipe collections defined in config
   l|ls [keyword]           List/search packages in default collection
   s|split <.rcp>           Split .rcp file into: .yaml, .hft, .json and .sh
                            with an extra placeholder processing step.
   u|unfold <.rcp>          Unfold .rcp file into debianized source tree.
   c|create <name>          Create talky template file: <name>.rcp
   m|minimal <name>         Create minimal template: <name>.rcp
   g|guess                  Guess recipe for the current source tree,
                            or just print a minimal template
   bg|boldguess             Guess and directly generate debian directory
   deb <.rcp>               Shortcut: Build .deb files from .rcp
   dsc <.rcp>               Shortcut: Build .dsc files from .rcp
EOH
}
